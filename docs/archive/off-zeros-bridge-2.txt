/-
  rh/RS/OffZerosBridge.lean


  Pinned-limit (u-trick, no field_simp) + constructor filler


  What you get:
  • tendsto_one_sub_div_one_add_of_tendsto_zero
  • continuousAt_inv₀_and_eventually_ne
  • tendsto_mobius_u_nhdsWithin
  • Theta_pinned_limit_from_N2  (fills the pinned-limit goal)
  • Theta_pinned_limit_from_N2_with_eventually_ne  (variant returning the eventual nonvanishing)


  All statements are ℂ-valued and work on nhdsWithin filters (Ω \ Z(ξ)) as you requested.
-/


import Mathlib.Topology.Algebra.Field
import Mathlib.Topology.MetricSpace.Basic
import Mathlib.Analysis.Complex.Basic


open Filter Topology


namespace RS


/-- If `u → 0` then `(1 - u) / (1 + u) → 1`. Also returns that `1 + u` is eventually nonzero.


This is the "mathlib-style" version on an arbitrary filter `l`. -/
theorem tendsto_one_sub_div_one_add_of_tendsto_zero
  {ι : Type*} {l : Filter ι} {u : ι → ℂ}
  (hu : Tendsto u l (𝓝 (0 : ℂ))) :
  Tendsto (fun i => (1 - u i) / (1 + u i)) l (𝓝 (1 : ℂ)) ∧
  (∀ᶠ i in l, 1 + u i ≠ 0) := by
  -- Eventual nonvanishing of `1+u i` since `(1+u) → 1 ≠ 0`.
  have h1 : Tendsto (fun i => (1 : ℂ) + u i) l (𝓝 (1 : ℂ)) := by
    -- continuity of z ↦ 1+z at 0, composed with u → 0
    refine ( (continuousAt_const.add continuousAt_id).tendsto ).comp hu
  -- Choose a small ball around 1 that misses 0; then values are eventually inside that ball.
  have h_ne : ∀ᶠ i in l, (1 : ℂ) + u i ≠ 0 := by
    -- dist(1, 0) = 1, so 0 ∉ ball(1, 1/2)
    have hz : (0 : ℂ) ∉ Metric.ball (1 : ℂ) (1/2 : ℝ) := by
      have : dist (0 : ℂ) 1 = (1 : ℝ) := by simpa [Complex.dist_eq] using dist_zero_right (1 : ℂ)
      -- 1 ≰ 1/2, hence 0 not in that ball
      have hgt : (1 : ℝ) > (1/2 : ℝ) := by norm_num
      -- Equivalently: dist(0,1) ≥ 1 > 1/2
      exact by
        -- If 0 ∈ ball(1,1/2) then dist(0,1) < 1/2, contradiction.
        intro hmem; exact (not_lt_of_ge (le_of_eq this)) (show dist (0 : ℂ) 1 < (1/2 : ℝ) from hmem)
    -- By tendsto, eventually (1+u i) lies in ball(1,1/2), hence not 0.
    refine ( (Metric.tendsto_nhds.1 h1) (1/2 : ℝ) (by norm_num) ).mono ?_
    intro i hi
    exact fun h0 => hz (by simpa [Complex.dist_eq, sub_eq_add_neg, h0, add_comm] using hi)


  -- Limit of Möbius at 0 by continuity of z ↦ (1 - z)/(1 + z) at z=0.
  have hcont0 : ContinuousAt (fun z : ℂ => (1 - z) / (1 + z)) (0 : ℂ) := by
    have hnum : ContinuousAt (fun z : ℂ => (1 : ℂ) - z) 0 :=
      continuousAt_const.sub continuousAt_id
    have hden : ContinuousAt (fun z : ℂ => (1 : ℂ) + z) 0 :=
      continuousAt_const.add continuousAt_id
    have hden_nz : ( (fun z : ℂ => (1 : ℂ) + z) ) 0 ≠ 0 := by simp
    simpa using hnum.div hden hden_nz


  have hlim : Tendsto (fun i => (1 - u i) / (1 + u i)) l (𝓝 ((1 : ℂ) : ℂ)) :=
    (hcont0.tendsto).comp hu


  exact ⟨hlim, h_ne⟩




/-- If `g` is continuous at `ρ` and `g ρ ≠ 0`, then `x ↦ (g x)⁻¹` is continuous at `ρ`
    and `g x ≠ 0` eventually on `𝓝 ρ`. (Mathlib-style helper.) -/
theorem continuousAt_inv₀_and_eventually_ne
  {α : Type*} [TopologicalSpace α] {g : α → ℂ} {ρ : α}
  (hg : ContinuousAt g ρ) (hρ : g ρ ≠ 0) :
  ContinuousAt (fun x => (g x)⁻¹) ρ ∧ (∀ᶠ x in 𝓝 ρ, g x ≠ 0) := by
  -- Continuity of inverse at a point where the value is nonzero.
  have h_inv : ContinuousAt (fun x => (g x)⁻¹) ρ := hg.inv₀ hρ
  -- Eventually nonvanishing: g(x) stays in a small ball around g ρ that avoids 0.
  have h_ne : ∀ᶠ x in 𝓝 ρ, g x ≠ 0 := by
    -- Pick radius r = ‖g ρ‖/2 > 0.
    have hr_pos : 0 < ‖g ρ‖ / 2 := by
      have : 0 < ‖g ρ‖ := by
        -- g ρ ≠ 0 ⇒ ‖g ρ‖ > 0
        have : ‖g ρ‖ ≠ 0 := by
          -- norm_eq_zero : ‖z‖ = 0 ↔ z = 0
          exact by
            intro hz; exact hρ (by simpa [hz] using (norm_eq_zero.mp ?_))
        -- convert to > 0
        have := lt_of_le_of_ne' (show (0 : ℝ) ≤ ‖g ρ‖ from norm_nonneg _) this
        exact this
      have : 0 < (‖g ρ‖) := this
      exact by have := (half_pos this); simpa [one_div] using this
    -- The open ball around g ρ with radius r avoids 0
    have h0_notin : (0 : ℂ) ∉ Metric.ball (g ρ) (‖g ρ‖ / 2) := by
      -- If 0 were in that ball, dist(0, g ρ) < ‖g ρ‖/2, contradiction since dist(0,gρ)=‖gρ‖.
      intro hmem
      have : dist (0 : ℂ) (g ρ) = ‖g ρ‖ := by simpa [Complex.dist_eq] using dist_zero_right (g ρ)
      have : ‖g ρ‖ < ‖g ρ‖ / 2 := by
        -- from membership in the ball
        simpa [Complex.dist_eq, sub_eq_add_neg, add_comm, add_left_comm, add_assoc] using hmem
      exact (lt_irrefl _ ) (lt_of_lt_of_le this (by have := (half_le_self (le_of_lt (show 0 < ‖g ρ‖ from ?hp)))
                                                        have ?hp : 0 < ‖g ρ‖ := by
                                                          have := norm_pos_iff.mpr hρ
                                                          simpa using this
                                                        exact this))
    -- By continuity, g(x) eventually lies in that ball, hence ≠ 0.
    refine ( (Metric.tendsto_nhds.1 hg.tendsto) (‖g ρ‖ / 2) hr_pos ).mono ?_
    intro x hx
    exact fun h0 => h0_notin (by simpa [Complex.dist_eq, sub_eq_add_neg, h0] using hx)


  exact ⟨h_inv, h_ne⟩




/-- `nhdsWithin` version of the u-trick limit: if `u → 0` on `𝓝[U] ρ`, then
    `(1 - u)/(1 + u) → 1` on `𝓝[U] ρ`, and `1 + u` is eventually nonzero there. -/
theorem tendsto_mobius_u_nhdsWithin
  {α : Type*} [TopologicalSpace α]
  {U : Set α} {ρ : α} {u : α → ℂ}
  (hu : Tendsto u (𝓝[U] ρ) (𝓝 (0 : ℂ))) :
  Tendsto (fun x => (1 - u x) / (1 + u x)) (𝓝[U] ρ) (𝓝 (1 : ℂ)) ∧
  (∀ᶠ x in 𝓝[U] ρ, 1 + u x ≠ 0) := by
  -- Reduce to the general filter lemma by treating l := nhdsWithin U ρ
  simpa using
    (tendsto_one_sub_div_one_add_of_tendsto_zero (ι := α) (l := 𝓝[U] ρ) (u := u) hu)


/-- **Pinned-limit via the u-trick (constructor filler).**
If near `ρ` within `U` we have `Θ = (1 - u)/(1 + u)` (eventually) and `u → 0` on `𝓝[U] ρ`,
then `Θ → 1` on `𝓝[U] ρ`. This is the exact limit you need for `hΘ_lim1_at_ξzero`. -/
theorem Theta_pinned_limit_from_N2
  {α : Type*} [TopologicalSpace α]
  {U : Set α} {ρ : α} {Θ u : α → ℂ}
  (hEq : (fun x => Θ x) =ᶠ[𝓝[U] ρ] (fun x => (1 - u x) / (1 + u x)))
  (hu : Tendsto u (𝓝[U] ρ) (𝓝 (0 : ℂ))) :
  Tendsto Θ (𝓝[U] ρ) (𝓝 (1 : ℂ)) := by
  have h := (tendsto_mobius_u_nhdsWithin (U := U) (ρ := ρ) (u := u) hu).1
  -- Replace the RHS by Θ using eventual equality.
  exact h.congr' hEq.symm


/-- Same as `Theta_pinned_limit_from_N2`, and also returns that `1 + u` is eventually nonzero
    on `𝓝[U] ρ`. Useful if your constructor needs both facts. -/
theorem Theta_pinned_limit_from_N2_with_eventually_ne
  {α : Type*} [TopologicalSpace α]
  {U : Set α} {ρ : α} {Θ u : α → ℂ}
  (hEq : (fun x => Θ x) =ᶠ[𝓝[U] ρ] (fun x => (1 - u x) / (1 + u x)))
  (hu : Tendsto u (𝓝[U] ρ) (𝓝 (0 : ℂ))) :
  Tendsto Θ (𝓝[U] ρ) (𝓝 (1 : ℂ)) ∧ (∀ᶠ x in 𝓝[U] ρ, 1 + u x ≠ 0) := by
  have h := tendsto_mobius_u_nhdsWithin (U := U) (ρ := ρ) (u := u) hu
  exact ⟨h.1.congr' hEq.symm, h.2⟩


end RS